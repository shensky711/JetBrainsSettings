<application>
  <component name="AppStorage">
    <histories>
      <item value="手续费" />
      <item value="withdrawals" />
      <item value="withdraw" />
      <item value="step size" />
      <item value="gained" />
      <item value="cooloff" />
      <item value="volatility" />
      <item value="session profit" />
      <item value="session_profit" />
      <item value="prevent" />
      <item value="QUANTITY" />
      <item value="'Converts the volume given in QUANTITY from USDT to the each coin's volume" />
      <item value="volatile" />
      <item value="volume" />
      <item value="portfolio" />
      <item value="fiat" />
      <item value="prices" />
      <item value="tickers" />
      <item value="bought" />
      <item value="TRAILING" />
      <item value="advanced" />
      <item value="bilinear" />
      <item value="尚未过期" />
      <item value="过期" />
      <item value="enqueue" />
      <item value="unSchedule" />
      <item value="Period" />
      <item value="scheduling" />
      <item value="scheduleing" />
      <item value="Subscribers" />
      <item value="Subscriber" />
      <item value="Subscribe" />
      <item value="Obsolete" />
      <item value="    'message': u'LINT ERROR: Lint found an issue registry (`androidx.annotation.experimental.lint.ExperimentalIssueRegistry`)      which did not specify the Lint API version it was compiled with.\n\n**     This means that the lint checks are likely not compatible.**\n\n     If you are the author of this lint check, make your lint `IssueRegistry` class contain\n\xa0\xa0override val api: Int = com.android.tools.lint.detector.api.CURRENT_API\nor from Java,\n\xa0\xa0@Override public int getApi() { return com.android.tools.lint.detector.api.ApiKt.CURRENT_API; }\n\nIf you are just using lint checks from a third party library you have no control over, you can disable these lint checks (if they misbehave) like this:\n\n\xa0\xa0\xa0\xa0android {\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0lintOptions {\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0disable &quot;UnsafeExperimentalUsageError&quot;,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0&quot;UnsafeExperimentalUsageWarning&quot;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0}\n. ObsoleteLintCustomCheck'}] " />
      <item value="potentially" />
      <item value="stealable" />
      <item value="Permit" />
      <item value="唤醒" />
      <item value="Spin" />
      <item value="CPU-bound" />
      <item value="then start yielding to reduce CPU pressure, and finally start adaptive parking" />
      <item value="Spin on the volatile field with an empty loop in hope that new work will arrive" />
      <item value="transation" />
      <item value="RETIRING" />
      <item value="/**  * Coroutine scheduler (pool of shared threads) which primary target is to distribute dispatched coroutines over worker threads,  * including both CPU-intensive and blocking tasks.  *  * Current scheduler implementation has two optimization targets:  * * Efficiency in the face of communication patterns (e.g., actors communicating via channel)  * * Dynamic resizing to support blocking calls without re-dispatching coroutine to separate &quot;blocking&quot; thread pool  *  * ### Structural overview  *  * Scheduler consists of [corePoolSize] worker threads to execute CPU-bound tasks and up to [maxPoolSize] (lazily created) threads  * to execute blocking tasks. Every worker has local queue in addition to global scheduler queue and global queue  * has priority over local queue to avoid starvation of externally-submitted (e.g., from Android UI thread) tasks and work-stealing is implemented  * on top of that queues to provide even load distribution and illusion of centralized run queue.  *  * ### Scheduling  *  * When a coroutine is dispatched from within scheduler worker, it's placed into the head of worker run queue.  * If the head is not empty, the task from the head is moved to the tail. Though it is unfair scheduling policy,  * it effectively couples communicating coroutines into one and eliminates scheduling latency that arises from placing task to the end of the queue.  * Placing former head to the tail is necessary to provide semi-FIFO order, otherwise queue degenerates to stack.  * When a coroutine is dispatched from an external thread, it's put into the global queue.  *  * ### Work stealing and affinity  *  * To provide even tasks distribution worker tries to steal tasks from other workers queues before parking when his local queue is empty.  * A non-standard solution is implemented to provide tasks affinity: task may be stolen only if it's 'stale' enough (based on the value of [WORK_STEALING_TIME_RESOLUTION_NS]).  * For this purpose monotonic global clock ([System.nanoTime]) is used and every task has associated with it submission time.  * This approach shows outstanding results when coroutines are cooperative, but as downside scheduler now depends on high-resolution global clock  * which may limit scalability on NUMA machines.  *  * ### Dynamic resizing and support of blocking tasks  *  * To support possibly blocking tasks [TaskMode] and CPU quota (via [cpuPermits]) are used.  * To execute [TaskMode.NON_BLOCKING] tasks from the global queue or to steal tasks from other workers  * the worker should have CPU permit. When a worker starts executing [TaskMode.PROBABLY_BLOCKING] task,  * it releases its CPU permit, giving a hint to a scheduler that additional thread should be created (or awaken)  * if new [TaskMode.NON_BLOCKING] task will arrive. When a worker finishes executing blocking task, it executes  * all tasks from its local queue (including [TaskMode.NON_BLOCKING]) and then parks as retired without polling  * global queue or trying to steal new tasks. Such approach may slightly limit scalability (allowing more than [corePoolSize] threads  * to execute CPU-bound tasks at once), but in practice, it is not, significantly reducing context switches and tasks re-dispatching.  *  * @suppress **This is unstable API and it is subject to change.**  */" />
      <item value="ACQUIRED" />
      <item value="线程相关的" />
      <item value="Over shoot" />
      <item value="Overshoot" />
      <item value="Due" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="120" />
        <entry key="ENGLISH" value="163" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="overrideFont" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="4e7ecd23edd56f56" />
      </youdao-translate>
    </option>
  </component>
</application>