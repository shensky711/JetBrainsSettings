<application>
  <component name="AppStorage">
    <histories>
      <item value=" pre-multipled " />
      <item value="初始" />
      <item value="曲线" />
      <item value="profileable" />
      <item value="策略" />
      <item value="expect" />
      <item value="幅度" />
      <item value="triangle" />
      <item value=" * An interpolator that can traverse a Path that extends from &lt;code&gt;Point&lt;/code&gt;  * &lt;code&gt;(0, 0)&lt;/code&gt; to &lt;code&gt;(1, 1)&lt;/code&gt;. The x coordinate along the &lt;code&gt;Path&lt;/code&gt;  * is the input value and the output is the y coordinate of the line at that point.  * This means that the Path must conform to a function &lt;code&gt;y = f(x)&lt;/code&gt;.  *  * &lt;p&gt;The &lt;code&gt;Path&lt;/code&gt; must not have gaps in the x direction and must not  * loop back on itself such that there can be two points sharing the same x coordinate.  * It is alright to have a disjoint line in the vertical direction:&lt;/p&gt;  * &lt;p&gt;&lt;blockquote&gt;&lt;pre&gt;  *     Path path = new Path();  *     path.lineTo(0.25f, 0.25f);  *     path.moveTo(0.25f, 0.5f);  *     path.lineTo(1f, 1f);  * &lt;/pre&gt;&lt;/blockquote&gt;&lt;/p&gt;" />
      <item value="类型" />
      <item value="分类" />
      <item value="lightStrength" />
      <item value="shininess" />
      <item value="specular" />
      <item value="diffuse" />
      <item value="ambient" />
      <item value="亮度" />
      <item value="精灵" />
      <item value="Snapshot" />
      <item value="不要初始化" />
      <item value="不需要初始化" />
      <item value="随机曲线" />
      <item value="interpolate" />
      <item value=" * Computes a natural (also known as &quot;free&quot;, &quot;unclamped&quot;) cubic spline interpolation for the data set.  * &lt;p&gt;  * The {@link #interpolate(double[], double[])} method returns a {@link PolynomialSplineFunction}  * consisting of n cubic polynomials, defined over the subintervals determined by the x values,  * {@code x[0] &lt; x[i] ... &lt; x[n].}  The x values are referred to as &quot;knot points.&quot;  * &lt;p&gt;  * The value of the PolynomialSplineFunction at a point x that is greater than or equal to the smallest  * knot point and strictly less than the largest knot point is computed by finding the subinterval to which  * x belongs and computing the value of the corresponding polynomial at &lt;code&gt;x - x[i] &lt;/code&gt; where  * &lt;code&gt;i&lt;/code&gt; is the index of the subinterval.  See {@link PolynomialSplineFunction} for more details.  * &lt;/p&gt;  * &lt;p&gt;  * The interpolating polynomials satisfy: &lt;ol&gt;  * &lt;li&gt;The value of the PolynomialSplineFunction at each of the input x values equals the  *  corresponding y value.&lt;/li&gt;  * &lt;li&gt;Adjacent polynomials are equal through two derivatives at the knot points (i.e., adjacent polynomials  *  &quot;match up&quot; at the knot points, as do their first and second derivatives).&lt;/li&gt;  * &lt;/ol&gt;  * &lt;p&gt;  * The cubic spline interpolation algorithm implemented is as described in R.L. Burden, J.D. Faires,  * &lt;u&gt;Numerical Analysis&lt;/u&gt;, 4th Ed., 1989, PWS-Kent, ISBN 0-53491-585-X, pp 126-131.  * &lt;/p&gt;" />
      <item value="Spline segment" />
      <item value="knots" />
      <item value="segment" />
      <item value="delimiters" />
      <item value="Spline segment interval delimiters." />
      <item value="     * The coefficients of the polynomial, ordered by degree -- i.e.,      * coefficients[0] is the constant term and coefficients[n] is the      * coefficient of x^n where n is the degree of the polynomial." />
      <item value="the degree of the polynomial." />
      <item value="polynomial" />
      <item value="degree" />
      <item value="Polynomial Function" />
      <item value="PolynomialFunction" />
      <item value="coefficients" />
      <item value="Polynomial Spline Function" />
      <item value="Polynomial SplineFunction" />
      <item value="PolynomialSplineFunction" />
      <item value=" cubic " />
      <item value=" cubic spline interpolation" />
      <item value="样条曲线" />
      <item value="derivative" />
      <item value=" * Computes a natural (also known as &quot;free&quot;, &quot;unclamped&quot;) cubic spline interpolation for the data set.  * &lt;p&gt;  * The {@link #interpolate(double[], double[])} method returns a {@link PolynomialSplineFunction}  * consisting of n cubic polynomials, defined over the subintervals determined by the x values,  * {@code x[0] &lt; x[i] ... &lt; x[n].}  The x values are referred to as &quot;knot points.&quot;  * &lt;p&gt;  * The value of the PolynomialSplineFunction at a point x that is greater than or equal to the smallest  * knot point and strictly less than the largest knot point is computed by finding the subinterval to which  * x belongs and computing the value of the corresponding polynomial at &lt;code&gt;x - x[i] &lt;/code&gt; where  * &lt;code&gt;i&lt;/code&gt; is the index of the subinterval.  See {@link PolynomialSplineFunction} for more details.  * &lt;/p&gt;  * &lt;p&gt;  * The interpolating polynomials satisfy: &lt;ol&gt;  * &lt;li&gt;The value of the PolynomialSplineFunction at each of the input x values equals the  *  corresponding y value.&lt;/li&gt;  * &lt;li&gt;Adjacent polynomials are equal through two derivatives at the knot points (i.e., adjacent polynomials  *  &quot;match up&quot; at the knot points, as do their first and second derivatives).&lt;/li&gt;  * &lt;/ol&gt;  * &lt;p&gt;  * The cubic spline interpolation algorithm implemented is as described in R.L. Burden, J.D. Faires,  * &lt;u&gt;Numerical Analysis&lt;/u&gt;, 4th Ed., 1989, PWS-Kent, ISBN 0-53491-585-X, pp 126-131.  * &lt;/p&gt;  *" />
      <item value=" * Computes a cubic spline interpolation for the data set using the Akima  * algorithm, as originally formulated by Hiroshi Akima in his 1970 paper  * &quot;A New Method of Interpolation and Smooth Curve Fitting Based on Local Procedures.&quot;  * J. ACM 17, 4 (October 1970), 589-602. DOI=10.1145/321607.321609  * http://doi.acm.org/10.1145/321607.321609  * &lt;p&gt;  * This implementation is based on the Akima implementation in the CubicSpline  * class in the Math.NET Numerics library. The method referenced is  * CubicSpline.InterpolateAkimaSorted  * &lt;/p&gt;  * &lt;p&gt;  * The {@link #interpolate(double[], double[]) interpolate} method returns a  * {@link PolynomialSplineFunction} consisting of n cubic polynomials, defined  * over the subintervals determined by the x values, {@code x[0] &lt; x[i] ... &lt; x[n]}.  * The Akima algorithm requires that {@code n &gt;= 5}.  * &lt;/p&gt;" />
      <item value="Construct a polynomial with the given coefficients.  The first element of the coefficients array is the constant term.  Higher degree coefficients follow in sequence.  The degree of the resulting polynomial is the index of the last non-null element of the array, or 0 if all elements are null.  The constructor makes a copy of the input array and assigns the copy to the coefficients property" />
      <item value="* Construct a polynomial with the given coefficients. The first element * of the coefficients array is the constant term. Higher degree * coefficients follow in sequence. The degree of the resulting polynomial * is the index of the last non-null element of the array, or 0 if all elements * are null. * &lt;p&gt; * The constructor makes a copy of the input array and assigns the copy to * the coefficients property.&lt;/p&gt;" />
      <item value="    /**      * Construct a polynomial with the given coefficients.  The first element      * of the coefficients array is the constant term.  Higher degree      * coefficients follow in sequence.  The degree of the resulting polynomial      * is the index of the last non-null element of the array, or 0 if all elements      * are null.      * &lt;p&gt;      * The constructor makes a copy of the input array and assigns the copy to      * the coefficients property.&lt;/p&gt;" />
      <item value="segments" />
      <item value="cubic" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="4" />
        <entry key="ENGLISH" value="247" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="overrideFont" value="true" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="4e7ecd23edd56f56" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>